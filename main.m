% The following code snippet shows how data is generated for all
% combination of |theta1| and |theta2| values and saved into a matrix to be
% used as training data. The reason for saving the data in two matrices is
% explained in the following section.

l1 = 10; % length of first arm
l2 = 7; % length of second arm
l3 = 4; % length of third arm

nr_p = 50;

theta1 = linspace(0, pi/4, nr_p); % all possible theta1 values
theta2 = linspace(0, pi/2, nr_p); % all possible theta2 values
theta3 = linspace(0, pi/4, nr_p); % all possible theta3 values

% [THETA1,THETA2] = meshgrid(theta1,theta2);
[THETA1,THETA2,THETA3] = meshgrid(theta1,theta2,theta3);

X = l1 * cos(THETA1) + l2 * cos(THETA1 + THETA2) + l3 * cos(THETA1 + THETA2 + THETA3); % compute x coordinates
Y = l1 * sin(THETA1) + l2 * sin(THETA1 + THETA2) + l3 * sin(THETA1 + THETA2 + THETA3); % compute y coordinates

% X = l1 * cos(THETA1) + l2 * cos(THETA1 + THETA2);
% Y = l1 * sin(THETA1) + l2 * sin(THETA1 + THETA2);

data1 = [X(:) Y(:) THETA1(:)]; % create x-y-theta1 dataset
data2 = [X(:) Y(:) THETA2(:)]; % create x-y-theta2 dataset
data3 = [X(:) Y(:) THETA3(:)]; % create x-y-theta3 dataset

%%
train_data1 = data1(1:2:end,:);
train_data2 = data2(1:2:end,:);
% train_data3 = data3(1:2:end,:);
val_data1 = data1(2:2:end,:);
val_data2 = data2(2:2:end,:);
% val_data3 = data3(2:2:end,:);

%%
TRAIN_P = 80;
PARTS = 25;
GROUP_SIZE = length(data1)/PARTS;

all_points = 1:length(data1);

parts = reshape(all_points, [PARTS, GROUP_SIZE]);

train_points = [];
val_points = [];
test_points = [];
for i = 1:PARTS
    t = datasample(parts(i,:),floor(TRAIN_P/100*GROUP_SIZE), 'Replace', false);
    rest = setdiff(parts(i,:), t);
    
    v = datasample(rest,floor(size(rest,2)/2), 'Replace', false);
    tp = setdiff(rest, v);
    
    train_points = [train_points t];
    val_points = [val_points v];
    test_points = [test_points tp];
end
%% load the points into data sets
train_data1 = data1(train_points, :);
train_data2 = data2(train_points, :);
train_data3 = data3(train_points, :);

val_data1 = data1(val_points, :);
val_data2 = data2(val_points, :);
val_data3 = data3(val_points, :);

test_data1 = data1(test_points, :);
test_data2 = data2(test_points, :);
test_data3 = data3(test_points, :);

%% save train/val/test data sets
save('train_points', 'train_points');
save('val_points', 'val_points');
save('test_points', 'test_points');

%% load train/val/test data points
load('train_points');
load('val_points');
load('test_points');
%%
% The following plot shows all the X-Y data points generated by cycling
% through different combinations of |theta1| and |theta2| and deducing x
% and y coordinates for each. The plot can be generated by using the
% code-snippet shown below. The plot is illustrated further for easier
% understanding.
%
plot(X(:),Y(:),'r.');
axis equal;
xlabel('X','fontsize',10)
ylabel('Y','fontsize',10)
title('X-Y coordinates generated for all theta1 and theta2 combinations using forward kinematics formula','fontsize',10)
%
% <<../invkine_grid.png>>
%
%%
opt = genfisOptions('SubtractiveClustering',...
                    'ClusterInfluenceRange',0.2);

fismat=genfis(train_data1(:,1:2),train_data1(:,3),opt);

opt = anfisOptions;
opt.InitialFIS = fismat;
opt.EpochNumber = 300;
epoch = 1:300;
opt.DisplayANFISInformation = 0;
opt.DisplayErrorValues = 0;
opt.DisplayStepSize = 0;
opt.DisplayFinalResults = 0;

% Train an ANFIS system using the first set of training data, |data1|.
disp('--> Training first ANFIS network.')

opt.ValidationData = val_data1;

[anfis1,trnErr,ss,anfis12,chkErr] = anfis(train_data1,opt);

figure
plot(epoch,trnErr,'o-b',epoch,chkErr,'x-r')
disp('--> Finished training first ANFIS network.')
%%
opt = genfisOptions('SubtractiveClustering',...
                    'ClusterInfluenceRange',0.2);

fismat=genfis(train_data2(:,1:2),train_data2(:,3),opt);

opt = anfisOptions;
opt.InitialFIS = fismat;
opt.EpochNumber = 300;
epoch = 1:300;
opt.DisplayANFISInformation = 0;
opt.DisplayErrorValues = 0;
opt.DisplayStepSize = 0;
opt.DisplayFinalResults = 0;

disp('--> Training second ANFIS network.')
% opt.InitialFIS = 25; % grid partitioning
opt.ValidationData = val_data2;

[anfis2,trnErr,ss,anfis22,chkErr] = anfis(train_data2,opt);

figure
plot(epoch,trnErr,'o-b',epoch,chkErr,'x-r')
disp('--> Finished training second ANFIS network.')
%%
% Change the number of input membership functions and train an ANFIS system
% using the third set of training data, |data3|.
tic
opt = genfisOptions('SubtractiveClustering',...
                    'ClusterInfluenceRange',0.2);

fismat=genfis(train_data3(:,1:2),train_data3(:,3),opt);

opt = anfisOptions;
opt.InitialFIS = fismat;
opt.EpochNumber = 300;
epoch = 1:300;
opt.DisplayANFISInformation = 0;
opt.DisplayErrorValues = 0;
opt.DisplayStepSize = 0;
opt.DisplayFinalResults = 0;

disp('--> Training third ANFIS network.')
% opt.InitialFIS = 25; % grid partitioning
opt.ValidationData = val_data3;

[anfis3,trnErr,ss,anfis32,chkErr] = anfis(train_data3,opt);

figure
plot(epoch,trnErr,'o-b',epoch,chkErr,'x-r')
disp('--> Finished training third ANFIS network.')
train_time = toc

%% save training
save('anfis1', 'anfis1');
%%
save('anfis2', 'anfis2');
%%
save('anfis3', 'anfis3');
%%
% extract validation data as set of XY
XY = val_data1(:,1:2);
THETA1P = evalfis(XY,anfis1); % theta1 predicted by anfis1
THETA2P = evalfis(XY,anfis2); % theta2 predicted by anfis2
% THETA3P = evalfis(XY,anfis3); % theta3 predicted by anfis3

NN_THETA = MLP_2joints({XY(:,1)';XY(:,2)'});
% NN_THETA = MLP_3joints({XY(:,1)';XY(:,2)';XY(:,3)'});
NN_THETA = NN_THETA{1}';
NN_THETA1P = NN_THETA(:,1);
NN_THETA2P = NN_THETA(:,2);
% NN_THETA3P = NN_THETA(:,3);

%% calculate overall RMSE, MEAN, MEADIAN and MAXIMUM on angles
angle_errors1 = THETA1P-val_data1(:,3);
angle_errors2 = THETA2P-val_data2(:,3);
% angle_errors3 = THETA3P-val_data3(:,3);

NN_angle_errors1 = NN_THETA1P-val_data1(:,3);
NN_angle_errors2 = NN_THETA2P-val_data2(:,3);
% NN_angle_errors3 = NN_THETA3P-val_data3(:,3);

%RMSE
RMSE1 = sqrt(mean((angle_errors1).^2));
RMSE2 = sqrt(mean((angle_errors2).^2));
% RMSE3 = sqrt(mean((angle_errors).^2));

NN_RMSE1 = sqrt(mean(NN_angle_errors1.^2));
NN_RMSE2 = sqrt(mean(NN_angle_errors2.^2));
% NN_RMSE3 = sqrt(mean(NN_angle_errors3.^2));

%MEAN
MEAN1 = mean(abs(angle_errors1-mean(angle_errors1)));
MEAN2 = mean(abs(angle_errors2-mean(angle_errors2)));
% MEAN3 = mean(abs(angle_errors3-mean(angle_errors3)));

NN_MEAN1 = mean(abs(NN_angle_errors1-mean(NN_angle_errors1)));
NN_MEAN2 = mean(abs(NN_angle_errors2-mean(NN_angle_errors2)));
% NN_MEAN3 = mean(abs(NN_angle_errors3-mean(NN_angle_errors3)));

%MEDIAN
MEDIAN1 = median(abs(angle_errors1-median(angle_errors1)));
MEDIAN2 = median(abs(angle_errors2-median(angle_errors2)));
% MEDIAN3 = median(abs(angle_errors3-median(angle_errors3)));

NN_MEDIAN1 = median(abs(NN_angle_errors1-median(NN_angle_errors1)));
NN_MEDIAN2 = median(abs(NN_angle_errors2-median(NN_angle_errors2)));
% NN_MEDIAN3 = median(abs(NN_angle_errors3-median(NN_angle_errors3)));

%MAXIMUM
MAXIMUM1 = max(abs(angle_errors1));
MAXIMUM2 = max(abs(angle_errors2));
% MAXIMUM3 = max(abs(angle_errors3));

NN_MAXIMUM1 = max(abs(NN_angle_errors1));
NN_MAXIMUM2 = max(abs(NN_angle_errors2));
% NN_MAXIMUM3 = max(abs(NN_angle_errors3));

["Calculation","Anfis","MLP","Delta";
 "RMSE1",RMSE1,NN_RMSE1,RMSE1-NN_RMSE1;
 "RMSE2",RMSE2,NN_RMSE2,RMSE2-NN_RMSE2;
 "RMSE3",RMSE3,NN_RMSE3,RMSE3-NN_RMSE3;
 "MEAN1",MEAN1,NN_MEAN1,MEAN1-NN_MEAN1;
 "MEAN2",MEAN2,NN_MEAN2,MEAN2-NN_MEAN2;
 "MEAN3",MEAN3,NN_MEAN3,MEAN3-NN_MEAN3;
 "MEDIAN1",MEDIAN1,NN_MEDIAN1,MEDIAN1-NN_MEDIAN1;
 "MEDIAN2",MEDIAN2,NN_MEDIAN2,MEDIAN2-NN_MEDIAN2;
 "MEDIAN3",MEDIAN3,NN_MEDIAN3,MEDIAN3-NN_MEDIAN3;
 "MAXIMUM1",MAXIMUM1,NN_MAXIMUM1,MAXIMUM1-NN_MAXIMUM1;
 "MAXIMUM2",MAXIMUM2,NN_MAXIMUM2,MAXIMUM2-NN_MAXIMUM2;
 "MAXIMUM3",MAXIMUM3,NN_MAXIMUM3,MAXIMUM3-NN_MAXIMUM3;
 ]
%% calculate overall RMSE, MEAN, MEADIAN and MAXIMUM on position
% Xp = l1 * cos(THETA1P) + l2 * cos(THETA1P + THETA2P) + l3 * cos(THETA1P + THETA2P + THETA3P); % compute x coordinates
% Yp = l1 * sin(THETA1P) + l2 * sin(THETA1P + THETA2P) + l3 * sin(THETA1P + THETA2P + THETA3P); % compute y coordinates

Xp = l1 * cos(THETA1P) + l2 * cos(THETA1P + THETA2P);
Yp = l1 * sin(THETA1P) + l2 * sin(THETA1P + THETA2P);

% NN_Xp = l1 * cos(NN_THETA1P) + l2 * cos(NN_THETA1P + NN_THETA2P) + l3 * cos(NN_THETA1P + NN_THETA2P + NN_THETA3P); % compute x coordinates
% NN_Yp = l1 * sin(NN_THETA1P) + l2 * sin(NN_THETA1P + NN_THETA2P) + l3 * sin(NN_THETA1P + NN_THETA2P + NN_THETA3P); % compute y coordinates

NN_Xp = l1 * cos(NN_THETA1P) + l2 * cos(NN_THETA1P + NN_THETA2P);
NN_Yp = l1 * sin(NN_THETA1P) + l2 * sin(NN_THETA1P + NN_THETA2P);

% euclidian distance
ed = sqrt((Xp-XY(:,1)).^2 + (Yp-XY(:,2)).^2);
NN_ed = sqrt((NN_Xp-XY(:,1)).^2 + (NN_Yp-XY(:,2)).^2);

% RMSE based on euclidian distance
RMSE = sqrt(mean(ed.^2));
NN_RMSE = sqrt(mean(NN_ed.^2));

%MEAN
MEAN = mean(abs(ed-mean(ed)));
NN_MEAN = mean(abs(NN_ed-mean(NN_ed)));

%MEDIAN
MEDIAN = median(abs(ed-median(ed)));
NN_MEDIAN = median(abs(NN_ed-median(NN_ed)));

%MAXIMUM
MAXIMUM = max(abs(ed));
NN_MAXIMUM = max(abs(NN_ed));

["Calculation","Anfis","MLP","Delta";
 "RMSE",RMSE,NN_RMSE,RMSE-NN_RMSE;
 "MEAN",MEAN,NN_MEAN,MEAN-NN_MEAN;
 "MEDIAN",MEDIAN,NN_MEDIAN,MEDIAN-NN_MEDIAN;
 "MAXIMUM",MAXIMUM,NN_MAXIMUM,MAXIMUM-NN_MAXIMUM
 ]

%% display quivers
err_X = Xp-XY(:,1);
err_Y = Yp-XY(:,2);

NN_err_X = NN_Xp-XY(:,1);
NN_err_Y = NN_Yp-XY(:,2);

% all_v = [err_X(:);err_Y(:);NN_err_X;NN_err_Y];
% a = min(all_v);
% b = max(all_v);
% 
% err_X = map(err_X(:), a, b);
% err_Y = map(err_Y(:), a, b);
% NN_err_X = map(NN_err_X(:), a, b);
% NN_err_Y = map(NN_err_Y(:), a, b);

figure
subplot(3,1,1)
quiver(XY(:,1),XY(:,2),err_X(:),err_Y(:))
title("Anfis");
axis([2 18 0 16]); 

subplot(3,1,2)
quiver(XY(:,1),XY(:,2),NN_err_X(:),NN_err_Y(:))
title("MLP");
axis([2 18 0 16]); 

subplot(3,1,3);
plot(XY(:,1),XY(:,2),'.'); 
title("Target");
axis([2 18 0 16]); 

%% 3d plot of errors
anfis_3 = sqrt(err_X.^2+err_Y.^2);
nn_3 = sqrt(NN_err_X.^2+NN_err_Y.^2);

CircleSize=100;
figure;
h2=scatter3(XY(:,1),XY(:,2),anfis_3,CircleSize,anfis_3,'s','filled');
xlabel('X axis');
ylabel('Y axis');
zlabel('Error');
title('Anfis');
colorbar;
figure;
h2=scatter3(XY(:,1),XY(:,2),nn_3,CircleSize,nn_3,'s','filled');
xlabel('X axis');
ylabel('Y axis');
zlabel('Error');
colorbar;
title('MLP');