function [Y,Xf,Af] = MLP_simple_1layer(X,~,~)
%MLP_SIMPLE_1LAYER neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 01-Apr-2019 15:14:45.
% 
% [Y] = MLP_simple_1layer(X,~,~) takes these arguments:
% 
%   X = 2xTS cell, 2 inputs over TS timesteps
%   Each X{1,ts} = 1xQ matrix, input #1 at timestep ts.
%   Each X{2,ts} = 1xQ matrix, input #2 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 2 outputs over TS timesteps.
%   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = -1.87867965644036;
x1_step1.gain = 0.087417632050152;
x1_step1.ymin = -1;

% Layer 1
b1 = [1.0082540230940819637;20.501902048675205492;8.972553363925751313;1.0895782729600886896;-0.21472983787063232297;1.2412120651340960986;-1.2732866573295607004;10.905210605926903611;-10.89693790159451936;1.661114736300413508;-3.036791437975039365;21.557726750525930015;-24.694403802073377818;-8.9515467500255301303;-0.47839687266416641709;5.9549267153290710297;9.76087302293494119];
IW1_1 = [-0.46157921651419792086;-17.106050061362701342;-5.5843500022591809895;-0.017092128418635818554;1.1342719688756230934;-0.13493126291195201016;1.2398824006608288872;-8.9790802839805632374;9.1178357145639044035;0.3245715123557649795;-0.89770170328431442286;-4.5158326032379410009;-9.3094477316536998757;-0.92316326341166721203;1.2380624249817404614;5.5904948970159775712;4.0919682564241739442];
IW1_2 = [-0.11299168063209538704;-0.50346724543800380758;-0.35405206113043469207;-0.22958544216356352452;-0.19952020844990472903;-0.23360657864085290769;0.063177763177803089589;-0.5755424783276334999;0.57334191509745069393;-0.089144714838029603943;0.21950402087138612406;-1.1295478476577163196;1.0310395492709720777;0.52371724608973246884;0.10898987061633012841;0.58201211596916668789;0.16955114333896212364];

% Layer 2
b2 = [2.2869653360417148136;-0.070681133460921224954;-11.87378758303649029];
LW2_1 = [-1.6576400349055828709 -4.1863796596352331747 -1.9503889277254877754 6.6780562474879925361 -0.67703359106769223086 -5.30926352174444105 0.97274922694917831389 -0.51504007764474069031 -0.41696785253369600399 -0.86014210690239134571 0.4360155207773562247 0.97894782676342884109 -0.39389269379652380731 0.18670832512823182237 -2.0278405332161244523 1.7569927146040875687 2.9250883926408541846;3.9634229778581504533 2.6143234820294289911 0.54753257253681297811 -8.9866253049664788222 3.4094752509715315902 3.6268523544604058806 -0.73086391427223540429 2.4051300249318012803 2.2388297347670125248 -3.9350898110966219257 -0.92104896349430454006 -2.5644463204347314189 0.70547773923679213404 -0.5232666617062559089 1.9736309184554992058 -1.0594492599536897703 0.94679112519300112627;-26.636789579711091847 4.7131795969510816846 7.4160219530252105002 5.6423600974009380238 -13.408861013855702282 15.609960783732860889 -5.8217075495230981019 -7.5874311826052105445 -7.2178076622521851746 28.69103358128026926 4.2533270331979569079 10.963336403620212778 -3.7523316950528435854 2.3687640342186613296 -12.923337585842046948 -11.015730449392862056 -11.392091640927779039];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [2.54647908947033;1.27323954473516;2.54647908947033];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Input 2
    % no processing
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1 + IW1_2*X{2,ts});
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(2,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
