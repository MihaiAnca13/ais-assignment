function [Y,Xf,Af] = MLP_3joints(X,~,~)
%MLP_3JOINTS neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 25-Mar-2019 11:08:42.
% 
% [Y] = MLP_3joints(X,~,~) takes these arguments:
% 
%   X = 3xTS cell, 3 inputs over TS timesteps
%   Each X{1,ts} = 1xQ matrix, input #1 at timestep ts.
%   Each X{2,ts} = 1xQ matrix, input #2 at timestep ts.
%   Each X{3,ts} = 1xQ matrix, input #3 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 3 outputs over TS timesteps.
%   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = -1.87867965644036;
x1_step1.gain = 0.087417632050152;
x1_step1.ymin = -1;

% Layer 1
b1 = [-0.59375237391018742539;13.555118137018935087;-25.026192913641136073;-12.163583270303677253;0.16666353400980177257;14.431132200811862987;-13.876872084966434429;1.1955816216285553022;-16.275678724577840484;3.3710509222471300994;0.35027838972755404034;3.8553259341931971349;44.142349603644191802;18.575104422422835881;0.35001932393742563043];
IW1_1 = [0.24903937115479862774;-13.392186077626362817;13.168889173115305269;7.7192741297424625202;-0.1581037483462509885;-14.11350555326683498;3.4078299053804101959;-0.2221434635406895064;10.678009968777603333;-0.13691936955918587726;0.14083440553039633381;2.3990987379614421293;-36.923649649500980274;-11.996437160639466413;-0.54437515593532925795];
IW1_2 = [-0.011799418305506620755;-0.24704323782051645919;0.96262447291512831526;0.51576096152598294164;0.0055372537248337830654;-0.26785480691739810277;0.57688322664511448856;-0.072218116870794740736;0.66227216640523689506;0.19926272582968235225;-0.029562198401200338177;2.0839502450356039986;-0.57030516862012570201;-0.55778917037272668367;-0.010780040773811368562];
IW1_3 = [0.37078532377233847095;1.1723037294976290656;2.9287633172186082753;0.14744075306323034535;0.059178205376295693607;1.0304445527592365206;1.6881616392865785858;-0.084536836087134623052;1.1727946051106994396;-1.1121059534226307441;-0.058117404812270741232;-0.68248201457503798739;-8.9486957612929405315;-2.4189800838593003007;-0.24414954261952312442];

% Layer 2
b2 = [37.598607159662208232;-33.923633486124849412;16.808406782809822033];
LW2_1 = [24.651422314512391409 10.880355454448995545 11.130295258427734595 5.6167818564524489844 -74.559728454436253742 -11.586239233653950365 1.3361313732045139169 -8.1132813065244810957 -3.4696210531345981209 -7.116346855705240948 -22.08899755787391328 37.536457460258738195 -2.1633816793367319775 -19.938474666682601821 28.938525543930204265;-21.369105385387296536 -12.425326822115904335 -14.803493387723912988 -7.5803954886322584272 29.2288644331612808 13.373287413614406205 -1.6447156933967079784 18.21675945197603852 4.6940962643358501438 -8.1469260453182581472 -16.19697013781829753 -27.488092174290098768 2.7925029006583561575 25.742571376696908203 -25.734650089797131756;26.431235921492049812 15.490687778912674233 17.839361071959750404 9.1485643654945469905 16.228535348500233937 -16.695357688701971455 2.0324967511626468308 -28.665683040823129346 -5.7130477048817809305 30.577966184615718248 50.97238724812972066 24.066710729564213977 -3.3148884997153080789 -31.264527842487503051 25.700899595771566908];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [2.54647908947033;1.27323954473516;2.54647908947033];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Input 2
    % no processing
    
    % Input 3
    % no processing
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1 + IW1_2*X{2,ts} + IW1_3*X{3,ts});
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(3,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
